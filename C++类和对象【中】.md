#  前言

在前面的学习我们知道，“空类”的大小是一个字节，其实空类并不空，任何一个类，它在程序中都会有6个默认成员函数。它们是被隐藏的，是编译器自动生成的。

它们分别是：

- 构造函数，析构函数；
- 拷贝构造函数；
- 赋值运算符重载；
- const成员函数；
- 取地址及const取地址操作符重载

当然，此文仅供初学者参考，C++语法之深入，让许多人中途而废，一知半解。本人不推荐在一开始就学得太深，往往最重要最经常使用的知识不是很难的，更深层次的内容会被更优秀的自己学习。**==重要的是知识要学以致用==**。

#  1. 构造函数

##  1.1 引例

在之前相对粗略（相较于繁杂的语法而言）的学习中，我们在“封装”这部分知道了：要使得私有成员变量被保护，需要提供对外公开的公有接口。比如Set函数：

```cpp
class Date
{
public:
    void SetDate(int year, int month, int day)
    {
        _year = year;
        _month = month;
        _day = day;
    }
private:
    int _year;
    int _month;
    int _day;
};
```

但在使用Get函数初始化成员变量之前，我们很自然地使用了这个语句：
```cpp
Date date;
```

很显然，它表明现在正在实例化一个对象。“实例化”表示它是占有实际空间的，也就是系统为这个对象开辟了内存，即建立了栈帧空间。在没有为成员变量赋予初始值时，它们存放的是随机值，编译器为了避免对象在被实例化后，程序员可能会忘记为某个成员变量赋初值，自动地调用一个隐藏的默认构造函数。

##  1.2 概念

每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数称之为构造函数（constructor）。构造函数的任务是初始化类对象的数据成员，**无论何时只要类的对象被创建，就会指向构造函数。**

##  1.3 特点

- 默认构造函数的函数名和类名相同；

- 无返回值；

- 对象被实例化时，构造函数会被自动调用；

- 只被调用一次；

- 构造函数之间（自定义和默认）构成函数重载。

  > ​	构造函数的名字和类名相同。和其他函数不一样的是，构造函数没有返回类型；除此之外类似于其他的函数，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。

##  1.4 自定义构造函数

由于默认构造函数的局限性，我们可以自定义构造函数，与默认构造函数构成函数重载。只要显式地自己写了构造函数，编译器就会调用我们自定义的而不调用默认的。

构造函数可以带参与否取决于情况，但是使用构造函数必须遵循语法。

**由于构造函数被频繁地调用，所以把它放在类中定义作为内联函数**。

```cpp
class Date
{
public:
  	//无参构造函数
    Date(){}
  	//有参构造函数
    Date(int year, int month, int day)
    {
        _year = year;
        _month = month;
        _day = day;
    }
private:
    int _year;
    int _month;
    int _day;
};

int main()
{
  	//无参调用
    Date date1;
  	//有参调用
    Date date2(2002,2,1);
		//无参调用不要加括号
    Date date3();
    return 0;
}

```

无参调用不要加括号，否则编译器（VS）会给出这样的警告：未调用原型函数（是否是有意用变量定义的？），有的编译器会直接指出这个函数未被使用。意思是，如果加上括号就相当于函数声明。

自定义构造函数通常也会跟缺省值搭配使用

```cpp
Date(int year = 2002, int month = 2, int day = 1)
    {
        _year = year;
        _month = month;
        _day = day;
    }
```

这样即使未使用开放的接口给成员赋值，初始值就是缺省值。例如需要初始化容量的数据结构，缺省值起着保险和简化步骤的作用。

虽然无参构造函数和有参构造函数可以与默认构造函数（那个被隐藏的，看不见的）同时存在，因为它们之间构成重载，但是一旦调用就会发生错误，存在二义性。例如将上面代码中的无参构造函数和有参构造函数分别注释掉，只留下另外一个然后编译，会发现留下无参的可以编译，另外一个不行，原因在下面。

##  1.5 默认构造函数

诸如这样的代码：

```cpp
Date date;
```

我们没有为这个对象提供初始值，因此我们知道它执行了默认初始化。类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做**默认构造函数**（default constructor）。默认构造函数无须任何实参。

编译器创建的构造函数又被称为**合成的默认构造函数**（synthesized default constructor）。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：

- 如果存在类内的初始值用它来初始化成员。例如C++11的补丁：在类的声明时给在`private`范围中的内置类型成员赋予初始值。
- 否则，默认初始化该成员。

默认构造函数：

- 不写编译器自动生成的；
- 全缺省参数的构造函数（自己写的）；
- 无参数的构造函数（自己写的）；
- C++11新增的补丁也算是（效果上算是，其实只有上面三种）。

**默认构造函数是如何“默认构造”的？**

- 内置类型成员变量不作处理；
- 自定义类型成员调用它自己的的默认构造函数。

> C++类型分类：
>
> - 内置类型/基本类型：int、double...还有各种类型的指针；
> - 自定义类型：通过class、struct关键字定义的类型。

**注意：只有当类没有声明然后构造函数式时，编译器才会自动地生成默认构造函数。**

##  1.6 小结

- 如果类的成员不需要显式地赋予值，就不用写构造函数，用默认的就足够满足语法要求了；
- 不能依赖默认构造函数的类需要自己显示地写一个全缺省的构造函数。在特殊情况如某些数据结构需要初始化容量，隐式地写比较好；
- C++11给出的补丁有时也是很有用的：在类的声明时给成员变量给初值。因为类中的成员变量的类型有内置类型和自定义类型，内置类型的成员的数量说不定，要显式地给值，所以给一个缺省值，使得补丁合理。

> 如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。

#  2. 析构函数

## 2.1 概念

析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。

析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数。由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。析构函数完成什么工作

例如在C语言学习的给栈数据结构释放内存Destroy函数：
```cpp
void Destory(Stack* st)
{
  free(st);
  st = NULL;
  st->capacity = 0;
  st->size = 0;
}
```

用析构代替它，假设类名是`Stack`：

```cpp
class Stack
{
public:
    //...各种方法
    ~Stack()
    {
        if(data)
        {
            free(data);
            data = NULL;
            _capacity = 0;
            _size = 0;
        }//其实只写free也可以，写上更规范
    }
private:
    int _size;
    int _capacity;
    int* data;
};

```

如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照**它们在类中出现的顺序进行初始化**。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。

> 也就是说，构造和析构，成员的创建和销毁的顺序对应了栈的特性。
>
> 注意：按在类中出现的顺序进行初始化，反言之在类外不论成员变量的次序如何，都不会影响成员变量在栈帧上的顺序。

在对象最后一次使用之后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。

在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。

##  2.2 特点

默认生成的析构函数：

- 不不处理内置类型，自定义类型会调用它的析构函数。比如内置类型是指针，析构函数不能轻易free它。

调用析构函数的情况：

- 当变量离开其作用域时；
- 当一个对象被销毁时，其成员被销毁；
- 数据结构（容器）被销毁时，其成员被销毁；

需要显式写析构函数的情况：

- 有动态开辟内存，并交给内置类型成员管理的情况。

不需要显式写析构函数的情况：

- 没有资源需要清理的（特指动态开辟），而且析构函数也没做什么时；
- 类的成员只有自定义成员，自己调用析构函数。

值得注意的是，析构函数不能重载。一个类只能有一个析构函数，若未自定义析构函数，则编译器会自动生成默认析构函数。